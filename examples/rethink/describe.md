# Project Proposal: The "Curiosity Engine"

<!-- NOTICE: This file was automatically generated by https://github.com/khimaros/enc using the following invocation: enc main.py -o describe.en -->

## High-Level Goal

The "Curiosity Engine" is a modular, command-line Python application designed as a playground for exploring various interesting computational concepts. It serves as a single, cohesive program that houses several distinct, interactive "modules," each demonstrating a different idea from fields like generative art, procedural generation, physics simulation, and data visualization.

The user can launch the program and choose which module they want to run from a simple menu.

## Technical Specifications

The program is implemented as a single Python script (`main.py`) with a focus on modularity and clear separation of concerns.

### Core Architecture

*   **Main Class (`CuriosityEngine`):** This class acts as the central orchestrator. It initializes all available modules, displays the main menu, handles user input for module selection, and manages the main application loop.
*   **Base Class (`Module`):** An abstract base class is defined to ensure a consistent interface for all modules. Every module inherits from `Module` and must implement a `run()` method, which serves as its main entry point. This makes it easy to add new modules in the future.
*   **Dependency Management:** The program gracefully handles missing optional libraries (`numpy`, `matplotlib`, `pygame`, `simpleaudio`). At startup, it checks for these libraries and prints a user-friendly warning if any are not found, informing the user that certain modules may not be available. For `simpleaudio`, a dummy object is created to prevent crashes and allow other modules to function.

### 1. Algorithmic Art Generator

This module generates visual art using a classic cellular automaton, **Conway's Game of Life**.

*   **Implementation:**
    *   It uses the `numpy` library for efficient grid manipulation. The state update logic cleverly calculates the number of neighbors for all cells simultaneously using `np.roll` to create shifted versions of the grid, which is significantly faster than nested loops.
    *   The visualization is handled by `matplotlib.animation`, which displays the simulation in real-time in a plot window.
*   **User Interaction:**
    *   The user can configure the simulation by providing parameters like grid size, number of iterations, initial random cell density, and a random seed for reproducibility.
*   **Output:**
    *   The final state of the grid is automatically saved as a PNG image (e.g., `game_of_life_final_state_seed_123.png`).

### 2. Procedural Narrative Engine

This module generates short, unique stories using a template-based grammar and a state machine.

*   **Implementation:**
    *   A vocabulary of words (nouns, verbs, adjectives) is stored in a dictionary.
    *   A simple **state machine**, also implemented with a dictionary, defines the narrative structure (e.g., `START` -> `DISCOVERY` -> `ACTION` -> `END`). Each state has a corresponding text template and a pointer to the next state.
    *   As the story is generated, a `story_context` dictionary is populated with the chosen words (e.g., `{CHARACTER: "the knight"}`) to ensure consistency across sentences.
*   **Output:**
    *   Each run produces a new, unique, multi-sentence micro-story printed to the console.

### 3. Mini Physics Simulator

This module provides a real-time visual simulation of 2D bouncing balls in a contained box.

*   **Implementation:**
    *   The `pygame` library is used for the rendering loop, drawing, and user input handling (closing the window).
    *   A `Ball` class encapsulates the properties of each object (position, velocity, radius, mass, color).
    *   The physics loop updates each ball's position based on its velocity and a constant `GRAVITY` vector.
    *   Collision detection is implemented for both ball-to-wall and ball-to-ball interactions.
        *   Wall collisions are simple reflections with a slight energy loss (`DAMPING`).
        *   Ball-to-ball collisions are handled using calculations that conserve momentum and kinetic energy for a realistic elastic collision response.
*   **User Interaction:**
    *   The user can specify the number of balls to include in the simulation.
*   **Output:**
    *   A real-time visual simulation is displayed in a Pygame window.

### 4. Interactive Data Explorer

This module presents a dataset in a novel way through **sonification**, translating data points into audible tones.

*   **Implementation:**
    *   It uses a hardcoded public dataset of global temperature anomalies from 1980-2019.
    *   A helper function maps each data value from its original range to a corresponding musical frequency. Lower values (colder years) map to lower frequencies, and higher values (warmer years) map to higher frequencies.
    *   `numpy` is used to generate a pure sine wave for each frequency.
    *   The `simpleaudio` library is used to play the generated audio buffer for each data point. The program waits for each tone to finish before playing the next, allowing the user to hear the progression.
*   **User Interaction:**
    *   The program prompts the user to press Enter to begin the sonification process.
*   **Output:**
    *   The program "plays" the dataset as a sequence of musical tones, allowing the listener to perceive the trend of rising temperatures over time. It also prints the year, data value, and corresponding frequency for each point.