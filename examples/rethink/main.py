#!/usr/bin/env python3
# NOTICE: This file was automatically generated by https://github.com/khimaros/enc using the following invocation:
# enc prompt.en -o main.py

"""
The Curiosity Engine
A modular program for exploring various computational concepts.
"""

import math
import random
import sys
import time
import re
import os

# --- Dependency Management ---
# A helper to provide user-friendly messages if a library is missing.
_MISSING_LIBS = []
try:
    import numpy as np
except ImportError:
    _MISSING_LIBS.append("numpy")

try:
    import matplotlib.pyplot as plt
    import matplotlib.animation as animation
except ImportError:
    _MISSING_LIBS.append("matplotlib")

try:
    import pygame
except ImportError:
    _MISSING_LIBS.append("pygame")

try:
    import simpleaudio as sa
except ImportError:
    # Use a dummy object if simpleaudio is not found, to allow other modules to run.
    _MISSING_LIBS.append("simpleaudio")
    class sa:
        @staticmethod
        def play_buffer(*args, **kwargs):
            print("\n[WARNING] 'simpleaudio' not found. Cannot play audio.")
            print("          Skipping audio playback for this data point.")
            # Return a dummy object with a wait_done method
            class DummyPlayObject:
                def wait_done(self):
                    pass
            return DummyPlayObject()

# --- Base Module ---
# This base class ensures all modules have a consistent interface.

# INPUT CONTENT: ## High-Level Goal
# INPUT CONTENT: ## Technical Specifications
class Module:
    """Abstract base class for all Curiosity Engine modules."""
    def __init__(self):
        self.name = "Abstract Module"
        self.description = "This module does nothing."

    def run(self):
        """The main entry point for the module."""
        print(f"Running {self.name}...")
        raise NotImplementedError("Each module must implement the 'run' method.")

    @staticmethod
    def get_int_input(prompt, default):
        """Helper to get validated integer input from the user."""
        try:
            val = input(f"{prompt} [default: {default}]: ")
            return int(val) if val else default
        except ValueError:
            print(f"Invalid input. Using default value: {default}")
            return default

# --- Module 1: Algorithmic Art Generator ---
# Implements Conway's Game of Life, a classic cellular automaton.

# INPUT CONTENT: ### 1. Algorithmic Art Generator
class AlgorithmicArtGenerator(Module):
    """
    Generates visual art using Conway's Game of Life.
    A cellular automaton where cells live or die based on a few simple rules,
    leading to complex and emergent patterns.
    """
    def __init__(self):
        self.name = "Algorithmic Art Generator (Game of Life)"
        self.description = "Generates and animates Conway's Game of Life, saving the final state."

    # INPUT CONTENT: *   Implement at least one classic generative art algorithm (e.g., ... cellular automata like Conway's Game of Life)
    def _update_grid(self, grid):
        """Calculates the next state of the grid based on the rules of Life."""
        # Count neighbors for each cell. We use periodic boundary conditions (torus).
        # The sum of 8 shifted versions of the grid gives the neighbor count.
        neighbors = (
            np.roll(grid, 1, axis=0) + np.roll(grid, -1, axis=0) +
            np.roll(grid, 1, axis=1) + np.roll(grid, -1, axis=1) +
            np.roll(np.roll(grid, 1, axis=0), 1, axis=1) +
            np.roll(np.roll(grid, 1, axis=0), -1, axis=1) +
            np.roll(np.roll(grid, -1, axis=0), 1, axis=1) +
            np.roll(np.roll(grid, -1, axis=0), -1, axis=1)
        )

        # Apply the rules of Life:
        # 1. A living cell with 2 or 3 live neighbours survives.
        # 2. A dead cell with 3 live neighbours becomes a live cell.
        # 3. All other live cells die in the next generation. All other dead cells stay dead.
        new_grid = (neighbors == 3) | (grid & (neighbors == 2))
        return new_grid.astype(int)

    # INPUT CONTENT: *   Allow the user to provide a seed value or tweak basic parameters
    # INPUT CONTENT: *   The program should be able to save the generated image to a common file format (e.g., PNG, SVG).
    def run(self):
        if "numpy" in _MISSING_LIBS or "matplotlib" in _MISSING_LIBS:
            print("[ERROR] This module requires 'numpy' and 'matplotlib'. Please install them.")
            return

        print(f"\n--- {self.name} ---")
        print(self.description)

        grid_size = self.get_int_input("Enter grid size (e.g., 100)", 100)
        iterations = self.get_int_input("Enter number of iterations (e.g., 200)", 200)
        density = self.get_int_input("Enter initial density percentage (1-99)", 20) / 100.0
        seed = self.get_int_input("Enter a random seed (integer) for reproducibility", random.randint(0, 10000))
        
        np.random.seed(seed)
        
        # Create initial random grid
        grid = (np.random.rand(grid_size, grid_size) < density).astype(int)

        fig, ax = plt.subplots()
        img = ax.imshow(grid, cmap='binary')
        ax.set_title(f"Game of Life - Seed: {seed}")
        
        print("\nRunning simulation... Close the plot window to finish.")

        # Animation function
        def animate(i):
            nonlocal grid
            grid = self._update_grid(grid)
            img.set_array(grid)
            ax.set_xlabel(f"Iteration: {i+1}")
            return [img]

        # Create and run the animation
        ani = animation.FuncAnimation(fig, animate, frames=iterations, interval=50, blit=True, repeat=False)
        plt.show()

        # Save the final state
        filename = f"game_of_life_final_state_seed_{seed}.png"
        plt.imsave(filename, grid, cmap='binary')
        print(f"Simulation finished. Final state saved as '{filename}'")


# --- Module 2: Procedural Narrative Engine ---
# Generates short stories using a state machine and grammar templates.

# INPUT CONTENT: ### 2. Procedural Narrative Engine
class ProceduralNarrativeEngine(Module):
    """
    Generates short, simple stories using a state machine to ensure
    a logical progression of events.
    """
    def __init__(self):
        self.name = "Procedural Narrative Engine"
        self.description = "Generates a unique micro-story using a state machine."

        # INPUT CONTENT: *   Maintain lists of nouns, verbs, adjectives, and other parts of speech
        self.vocab = {
            "CHARACTER": ["the knight", "the wizard", "a lonely traveler", "the merchant"],
            "LOCATION": ["the dark forest", "the bustling city", "a forgotten ruin", "the king's castle"],
            "OBJECT": ["an ancient scroll", "a glowing potion", "a heavy key", "the dragon's tooth"],
            "ACTION_FIND": ["discovered", "found", "stumbled upon", "uncovered"],
            "ACTION_USE": ["read", "drank", "used", "inspected"],
            "ADJECTIVE": ["mysterious", "shimmering", "ominous", "valuable"],
            "CONSEQUENCE": ["felt a surge of power", "unlocked a hidden door", "revealed a secret map", "fell into a deep slumber"],
        }
        
        # INPUT CONTENT: *   **Stretch Goal:** Implement a simple state machine to create a multi-sentence narrative
        # INPUT CONTENT: *   Define a simple grammar (e.g., using context-free grammar or templates)
        self.states = {
            "START": {
                "template": "{CHARACTER} arrived at {LOCATION}.",
                "next_state": "DISCOVERY"
            },
            "DISCOVERY": {
                "template": "There, they {ACTION_FIND} a {ADJECTIVE} {OBJECT}.",
                "next_state": "ACTION"
            },
            "ACTION": {
                "template": "Curious, they {ACTION_USE} the {OBJECT} and {CONSEQUENCE}.",
                "next_state": "END"
            },
            "END": {
                "template": "Their journey was changed forever.",
                "next_state": None
            }
        }

    def _fill_template(self, template, story_context):
        """Fills a template string using the vocabulary and story context."""
        # Regex to find all placeholders like {KEY}
        placeholders = re.findall(r'\{(\w+)\}', template)
        
        sentence = template
        for key in placeholders:
            if key in story_context:
                # Use the word already chosen for this story
                word = story_context[key]
            elif key in self.vocab:
                # Choose a new word and save it to the context
                word = random.choice(self.vocab[key])
                story_context[key] = word
            else:
                # Placeholder not found in vocab, leave it as is
                word = f"{{{key}}}"
            
            sentence = sentence.replace(f"{{{key}}}", word, 1)
        return sentence.capitalize()

    # INPUT CONTENT: *   The program should generate a new, unique text snippet each time it is run.
    def run(self):
        print(f"\n--- {self.name} ---")
        print(self.description, "\n")
        
        current_state_name = "START"
        story_context = {}  # Stores chosen words (e.g., CHARACTER) to maintain consistency
        story = []

        while current_state_name:
            state_info = self.states[current_state_name]
            template = state_info["template"]
            
            sentence = self._fill_template(template, story_context)
            story.append(sentence)
            
            current_state_name = state_info["next_state"]

        print(" ".join(story))

# --- Module 3: Mini Physics Simulator ---
# Implements a 2D simulation of bouncing balls in a box.

# INPUT CONTENT: ### 3. Mini Physics Simulator
class MiniPhysicsSimulator(Module):
    """
    A simple 2D physics simulation of bouncing balls in a box,
    demonstrating gravity and elastic collisions.
    """
    def __init__(self):
        self.name = "Mini Physics Simulator (Bouncing Balls)"
        self.description = "A real-time visual simulation of bouncing balls in a container."

    # INPUT CONTENT: *   A simulation of bouncing balls in a box, accounting for gravity and conservation of momentum/energy.
    def run(self):
        if "pygame" in _MISSING_LIBS:
            print("[ERROR] This module requires 'pygame'. Please install it.")
            return

        print(f"\n--- {self.name} ---")
        print(self.description)
        num_balls = self.get_int_input("Enter number of balls", 15)
        
        # Pygame setup
        pygame.init()
        WIDTH, HEIGHT = 800, 600
        screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Bouncing Balls Simulation")
        clock = pygame.time.Clock()
        
        # Physics constants
        GRAVITY = pygame.Vector2(0, 0.5)
        DAMPING = 0.999 # Energy loss on wall bounce
        
        # Ball class
        class Ball:
            def __init__(self, x, y, radius, color):
                self.pos = pygame.Vector2(x, y)
                self.vel = pygame.Vector2(random.uniform(-3, 3), random.uniform(-3, 3))
                self.radius = radius
                self.color = color
                self.mass = radius ** 2 # Mass proportional to area

            def update(self):
                self.vel += GRAVITY
                self.pos += self.vel
                self.draw()
                self.check_wall_collision()

            def draw(self):
                pygame.draw.circle(screen, self.color, self.pos, self.radius)

            def check_wall_collision(self):
                # Left/Right walls
                if self.pos.x - self.radius < 0:
                    self.pos.x = self.radius
                    self.vel.x *= -DAMPING
                elif self.pos.x + self.radius > WIDTH:
                    self.pos.x = WIDTH - self.radius
                    self.vel.x *= -DAMPING
                # Top/Bottom walls
                if self.pos.y - self.radius < 0:
                    self.pos.y = self.radius
                    self.vel.y *= -DAMPING
                elif self.pos.y + self.radius > HEIGHT:
                    self.pos.y = HEIGHT - self.radius
                    self.vel.y *= -DAMPING

        # Ball-to-ball collision logic
        def handle_ball_collisions(balls):
            for i in range(len(balls)):
                for j in range(i + 1, len(balls)):
                    b1, b2 = balls[i], balls[j]
                    dist_vec = b1.pos - b2.pos
                    dist = dist_vec.length()
                    
                    if dist < b1.radius + b2.radius:
                        # Collision detected, resolve it
                        # 1. Separate overlapping balls
                        overlap = b1.radius + b2.radius - dist
                        b1.pos += dist_vec.normalize() * overlap / 2
                        b2.pos -= dist_vec.normalize() * overlap / 2

                        # 2. Elastic collision response (conservation of momentum/energy)
                        normal = dist_vec.normalize()
                        tangent = pygame.Vector2(-normal.y, normal.x)
                        
                        v1n = b1.vel.dot(normal)
                        v1t = b1.vel.dot(tangent)
                        v2n = b2.vel.dot(normal)
                        v2t = b2.vel.dot(tangent)

                        # New normal velocities
                        m1, m2 = b1.mass, b2.mass
                        v1n_new = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2)
                        v2n_new = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2)

                        # Update velocities
                        b1.vel = v1n_new * normal + v1t * tangent
                        b2.vel = v2n_new * normal + v2t * tangent

        # Create balls
        balls = []
        for _ in range(num_balls):
            radius = random.randint(10, 30)
            balls.append(Ball(
                random.randint(radius, WIDTH - radius),
                random.randint(radius, HEIGHT - radius),
                radius,
                (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))
            ))

        # INPUT CONTENT: *   Create a canvas or environment where objects can exist.
        # INPUT CONTENT: *   Implement a basic physics loop that updates object states over time.
        # INPUT CONTENT: *   The simulation should be rendered visually in real-time.
        running = True
        print("Running simulation... Close the Pygame window to exit.")
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            screen.fill((20, 20, 40)) # Dark blue background
            
            for ball in balls:
                ball.update()
            
            handle_ball_collisions(balls)

            pygame.display.flip()
            clock.tick(60) # Limit to 60 FPS

        pygame.quit()


# --- Module 4: Interactive Data Explorer ---
# Sonifies a dataset, translating data points into audible tones.

# INPUT CONTENT: ### 4. Interactive Data Explorer
class InteractiveDataExplorer(Module):
    """
    An interactive data "sonification" tool. It ingests a simple dataset
    and translates its values into audible musical tones, allowing the user
    to "hear" the data.
    """
    def __init__(self):
        self.name = "Interactive Data Explorer (Sonification)"
        self.description = "Translates a dataset of global temperature anomalies into sound."

    def _get_note(self, value, data_min, data_max, base_freq=220.0, freq_range=660.0):
        """Maps a data value to a musical frequency."""
        # Normalize value to 0-1 range
        normalized = (value - data_min) / (data_max - data_min)
        # Map to frequency range (A3 to A5)
        return base_freq + normalized * freq_range

    def _generate_sine_wave(self, frequency, duration_ms, sample_rate=44100):
        """Generates a sine wave for a given frequency and duration."""
        num_samples = int(sample_rate * duration_ms / 1000)
        t = np.linspace(0, duration_ms / 1000, num_samples, False)
        audio = np.sin(frequency * t * 2 * np.pi)
        # Normalize to 16-bit range
        audio *= 32767 / np.max(np.abs(audio))
        audio = audio.astype(np.int16)
        return audio

    # INPUT CONTENT: *   Choose a compelling public dataset (e.g., ... global temperature anomalies)
    # INPUT CONTENT: *   Instead of a standard chart, present the data in a novel way. ... a "sonification" module
    def run(self):
        if "numpy" in _MISSING_LIBS:
            print("[ERROR] This module requires 'numpy'. Please install it.")
            return

        print(f"\n--- {self.name} ---")
        print(self.description)
        print("You will hear a series of tones. Lower tones represent colder years,")
        print("higher tones represent warmer years. Listen for the trend.")
        input("\nPress Enter to begin sonification...")

        # Dataset: Global Temperature Anomaly (deg C) from 1980-2019
        # Source: Simplified from NASA GISS data
        data = {
            1980: 0.27, 1981: 0.31, 1982: 0.13, 1983: 0.32, 1984: 0.16,
            1985: 0.12, 1986: 0.19, 1987: 0.34, 1988: 0.34, 1989: 0.28,
            1990: 0.45, 1991: 0.42, 1992: 0.23, 1993: 0.26, 1994: 0.32,
            1995: 0.46, 1996: 0.34, 1997: 0.48, 1998: 0.64, 1999: 0.42,
            2000: 0.41, 2001: 0.55, 2002: 0.63, 2003: 0.62, 2004: 0.55,
            2005: 0.69, 2006: 0.63, 2007: 0.66, 2008: 0.54, 2009: 0.66,
            2010: 0.72, 2011: 0.61, 2012: 0.65, 2013: 0.68, 2014: 0.75,
            2015: 0.90, 2016: 1.02, 2017: 0.93, 2018: 0.85, 2019: 0.98
        }
        
        years = sorted(data.keys())
        values = [data[y] for y in years]
        data_min, data_max = min(values), max(values)
        
        sample_rate = 44100
        
        # INPUT CONTENT: *   The user should be able to filter or query the data in a simple way.
        print("\nSonifying data from 1980 to 2019...")
        for year in years:
            value = data[year]
            frequency = self._get_note(value, data_min, data_max)
            print(f"Year: {year}, Anomaly: {value:+.2f}°C, Freq: {frequency:.2f} Hz")
            
            # Generate and play the sound
            note_audio = self._generate_sine_wave(frequency, duration_ms=250, sample_rate=sample_rate)
            play_obj = sa.play_buffer(note_audio, 1, 2, sample_rate)
            play_obj.wait_done() # Wait for the sound to finish before playing the next
        
        print("\nSonification complete.")

# --- Main Application ---
# The main class that orchestrates the selection and execution of modules.

# INPUT CONTENT: ## Project Proposal: The "Curiosity Engine"
# INPUT CONTENT: ## High-Level Goal
class CuriosityEngine:
    def __init__(self):
        self.modules = {
            "1": AlgorithmicArtGenerator(),
            "2": ProceduralNarrativeEngine(),
            "3": MiniPhysicsSimulator(),
            "4": InteractiveDataExplorer(),
        }

    def start(self):
        print("=" * 50)
        print(" Welcome to the Curiosity Engine!")
        print(" A playground for interesting computational concepts.")
        print("=" * 50)
        
        if _MISSING_LIBS:
            print("\n[SETUP WARNING] The following recommended libraries were not found:")
            for lib in _MISSING_LIBS:
                print(f"  - {lib}")
            print("Some modules may not run. Please install them (e.g., 'pip install numpy matplotlib pygame simpleaudio').")

        while True:
            print("\nPlease choose a module to run:")
            for key, module in self.modules.items():
                print(f"  [{key}] {module.name}")
            print("  [q] Quit")
            
            choice = input("> ").strip().lower()
            
            if choice == 'q':
                print("Exiting the Curiosity Engine. Goodbye!")
                break
            elif choice in self.modules:
                try:
                    self.modules[choice].run()
                except Exception as e:
                    print(f"\n[UNHANDLED ERROR] An error occurred in module '{self.modules[choice].name}':")
                    print(f"  {e}")
                    print("Returning to the main menu.")
            else:
                print("Invalid choice. Please try again.")

# --- Program Entry Point ---
if __name__ == "__main__":
    engine = CuriosityEngine()
    engine.start()
    sys.exit(0)
