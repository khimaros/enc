// NOTICE: a file generated by https://github.com/khimaros/enc using the following invocation: enc main.en -o src/main.rs --context-files Cargo.toml:assets/balloon.svg
#
![allow(clippy::type_complexity)
]

// this is the main entrypoint for the program
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use rand::prelude::*;

// Constants for the simulation
const BALLOON_SPAWN_TIME_SECONDS: f32 = 0.8;
const BALLOON_SPEED_MIN: f32 = 100.0;
const BALLOON_SPEED_MAX: f32 = 200.0;
const BALLOON_SCALE: f32 = 0.4;

const CONFETTI_COUNT: i32 = 50;
const CONFETTI_GRAVITY: f32 = -980.0;
const CONFETTI_LIFETIME_SECONDS: f32 = 2.0;
const CONFETTI_INITIAL_VELOCITY: f32 = 300.0;

const TICKER_SPEED: f32 = 100.0;
const TICKER_TEXT: &str = "ENC +++ BEVY ENGINE -- RUST PROGRAMMING LANGUAGE INCR 5.25 -- GRAPHICS RENDERING UP 2.13 -- FUN FACTOR MAX +++ ";

// Component to mark a balloon entity
// the window has colorful balloons floating up the screen randomly
#[derive(Component)]
struct Balloon {
    speed: f32,
}

// Component to mark a confetti particle
// when the user clicks on the balloons they pop and confetti comes out
#[derive(Component)]
struct Confetti {
    velocity: Vec2,
    lifetime: Timer,
}

// Component to mark the scrolling ticker text
// there should be a retro stock ticker continuously scrolling across the bottom
#[derive(Component)]
struct TickerText;

// Resource to hold the balloon texture handle
// the balloon asset is "balloon.png" which is generated from "balloon.svg"
#[derive(Resource)]
struct BalloonTexture(Handle<Image>);

// Resource to manage the balloon spawn timer
#[derive(Resource)]
struct BalloonSpawnTimer(Timer);

fn main() {
    // this is the main entrypoint for the program
    // the program opens a window when started
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "Balloons!".into(),
                ..default()
            }),
            ..default()
        }))
        .add_systems(Startup, setup_system)
        .add_systems(
            Update,
            (
                spawn_balloons_system,
                move_balloons_system,
                pop_balloons_system,
                animate_confetti_system,
                ticker_system,
                despawn_offscreen_entities_system,
            ),
        )
        .run();
}

// the program opens a window when started
// the balloon asset is "balloon.png" which is generated from "balloon.svg"
// there should be a retro stock ticker continuously scrolling across the bottom
fn setup_system(mut commands: Commands, asset_server: Res<AssetServer>) {
    // Spawn the 2D camera
    commands.spawn(Camera2dBundle::default());

    // Load the balloon texture and store it as a resource
    let balloon_handle = asset_server.load("balloon.png");
    commands.insert_resource(BalloonTexture(balloon_handle));

    // Create and insert the balloon spawn timer resource
    commands.insert_resource(BalloonSpawnTimer(Timer::from_seconds(
        BALLOON_SPAWN_TIME_SECONDS,
        TimerMode::Repeating,
    )));

    // Create the ticker UI
    commands
        .spawn(NodeBundle {
            style: Style {
                width: Val::Percent(100.0),
                height: Val::Px(30.0),
                position_type: PositionType::Absolute,
                bottom: Val::Px(0.0),
                left: Val::Px(0.0),
                justify_content: JustifyContent::FlexStart,
                align_items: AlignItems::Center,
                overflow: Overflow::clip(),
                ..default()
            },
            background_color: Color::BLACK.into(),
            ..default()
        })
        .with_children(|parent| {
            // The text that will scroll
            parent.spawn((
                TextBundle::from_section(
                    TICKER_TEXT.repeat(5), // Repeat text to ensure it's long enough to scroll smoothly
                    TextStyle {
                        font_size: 20.0,
                        color: Color::LIME_GREEN,
                        ..default()
                    },
                )
                .with_style(Style {
                    position_type: PositionType::Absolute,
                    left: Val::Px(0.0), // Start at the left edge
                    ..default()
                }),
                TickerText,
            ));
        });
}

// the window has colorful balloons floating up the screen randomly
fn spawn_balloons_system(
    mut commands: Commands,
    time: Res<Time>,
    mut spawn_timer: ResMut<BalloonSpawnTimer>,
    balloon_texture: Res<BalloonTexture>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    spawn_timer.0.tick(time.delta());
    if !spawn_timer.0.just_finished() {
        return;
    }

    let window = window_query.get_single().unwrap();
    let mut rng = rand::thread_rng();

    // Random horizontal position
    let random_x = rng.gen_range(-window.width() / 2.0..window.width() / 2.0);
    // Start just below the screen
    let y_pos = -window.height() / 2.0 - 100.0;

    // Random color
    let random_color = Color::hsl(rng.gen_range(0.0..360.0), 0.9, 0.7);

    // Random speed
    let random_speed = rng.gen_range(BALLOON_SPEED_MIN..BALLOON_SPEED_MAX);

    // the balloons should have a realistic shape (rounded and oblong, as real balloons are)
    commands.spawn((
        SpriteBundle {
            texture: balloon_texture.0.clone(),
            transform: Transform {
                translation: Vec3::new(random_x, y_pos, 0.0),
                scale: Vec3::splat(BALLOON_SCALE),
                ..default()
            },
            sprite: Sprite {
                color: random_color,
                ..default()
            },
            ..default()
        },
        Balloon { speed: random_speed },
    ));
}

// the window has colorful balloons floating up the screen randomly
fn move_balloons_system(mut balloon_query: Query<(&mut Transform, &Balloon)>, time: Res<Time>) {
    for (mut transform, balloon) in balloon_query.iter_mut() {
        transform.translation.y += balloon.speed * time.delta_seconds();
    }
}

// when the user clicks on the balloons they pop and confetti comes out
fn pop_balloons_system(
    mut commands: Commands,
    mouse_button_input: Res<ButtonInput<MouseButton>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    camera_query: Query<(&Camera, &GlobalTransform)>,
    balloon_query: Query<(Entity, &Transform, &Handle<Image>), With<Balloon>>,
    assets: Res<Assets<Image>>,
) {
    if !mouse_button_input.just_pressed(MouseButton::Left) {
        return;
    }

    let window = window_query.get_single().unwrap();
    let (camera, camera_transform) = camera_query.get_single().unwrap();

    if let Some(cursor_pos) = window.cursor_position() {
        if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {
            for (balloon_entity, balloon_transform, image_handle) in balloon_query.iter() {
                // Get the balloon's size from its image asset
                if let Some(image) = assets.get(image_handle) {
                    let image_size = image.size().as_vec2();
                    let balloon_size = image_size * balloon_transform.scale.truncate();

                    // Simple AABB collision check
                    let half_width = balloon_size.x / 2.0;
                    let half_height = balloon_size.y / 2.0;
                    let balloon_pos = balloon_transform.translation.truncate();

                    if world_pos.x >= balloon_pos.x - half_width
                        && world_pos.x <= balloon_pos.x + half_width
                        && world_pos.y >= balloon_pos.y - half_height
                        && world_pos.y <= balloon_pos.y + half_height
                    {
                        // Pop the balloon
                        commands.entity(balloon_entity).despawn();

                        // Spawn confetti
                        let mut rng = rand::thread_rng();
                        for _ in 0..CONFETTI_COUNT {
                            let angle = rng.gen_range(0.0..std::f32::consts::PI * 2.0);
                            let speed = rng.gen_range(0.0..CONFETTI_INITIAL_VELOCITY);
                            let velocity = Vec2::new(angle.cos() * speed, angle.sin() * speed);
                            let color = Color::hsl(rng.gen_range(0.0..360.0), 1.0, 0.5);

                            commands.spawn((
                                SpriteBundle {
                                    sprite: Sprite {
                                        color,
                                        custom_size: Some(Vec2::new(4.0, 4.0)),
                                        ..default()
                                    },
                                    transform: Transform::from_translation(
                                        balloon_transform.translation,
                                    ),
                                    ..default()
                                },
                                Confetti {
                                    velocity,
                                    lifetime: Timer::from_seconds(
                                        CONFETTI_LIFETIME_SECONDS,
                                        TimerMode::Once,
                                    ),
                                },
                            ));
                        }
                        // Only pop one balloon per click
                        break;
                    }
                }
            }
        }
    }
}

// when the user clicks on the balloons they pop and confetti comes out
fn animate_confetti_system(
    mut commands: Commands,
    mut confetti_query: Query<(Entity, &mut Transform, &mut Confetti)>,
    time: Res<Time>,
) {
    for (entity, mut transform, mut confetti) in confetti_query.iter_mut() {
        // Apply gravity
        confetti.velocity.y += CONFETTI_GRAVITY * time.delta_seconds();
        // Move particle
        transform.translation.x += confetti.velocity.x * time.delta_seconds();
        transform.translation.y += confetti.velocity.y * time.delta_seconds();

        // Despawn if lifetime is over
        confetti.lifetime.tick(time.delta());
        if confetti.lifetime.finished() {
            commands.entity(entity).despawn();
        }
    }
}

// there should be a retro stock ticker continuously scrolling across the bottom
fn ticker_system(
    mut ticker_query: Query<(&mut Style, &Node), With<TickerText>>,
    parent_query: Query<(&Node, &Children)>,
    time: Res<Time>,
) {
    for (mut style, node) in ticker_query.iter_mut() {
        // This assumes the ticker text's parent is the black bar container.
        // Bevy's UI system might not have calculated sizes on the first few frames.
        if let Ok((parent_node, _)) = parent_query.get_single() {
            let text_width = node.size().x;
            let container_width = parent_node.size().x;

            if text_width == 0.0 || container_width == 0.0 {
                continue; // Wait for layout system to run
            }

            if let Val::Px(current_pos) = style.left {
                let mut new_pos = current_pos - TICKER_SPEED * time.delta_seconds();

                // If the text has scrolled completely off the left, reset it to the right
                // We use a fraction of the text width to handle the repeated text pattern
                if new_pos < -text_width / 5.0 {
                    new_pos += text_width / 5.0;
                }

                style.left = Val::Px(new_pos);
            }
        }
    }
}

// Helper system to despawn balloons that go off-screen
fn despawn_offscreen_entities_system(
    mut commands: Commands,
    query: Query<(Entity, &Transform), With<Balloon>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    let window = window_query.get_single().unwrap();
    let top_boundary = window.height() / 2.0 + 100.0; // A little buffer

    for (entity, transform) in query.iter() {
        if transform.translation.y > top_boundary {
            commands.entity(entity).despawn();
        }
    }
}
