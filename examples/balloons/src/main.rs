// NOTICE: a file was automatically generated by https://github.com/khimaros/enc using the following invocation: enc main.en -o src/main.rs --context-files Cargo.toml:assets/balloon.svg
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use rand::prelude::*;

const BALLOON_SPAWN_TIME: f32 = 1.0;
const BALLOON_SIZE: Vec2 = Vec2::new(100.0, 150.0);
const MIN_BALLOON_SPEED: f32 = 100.0;
const MAX_BALLOON_SPEED: f32 = 300.0;

const CONFETTI_COUNT: u32 = 30;
const CONFETTI_GRAVITY: f32 = 980.0;
const CONFETTI_LIFETIME: f32 = 1.5;
const CONFETTI_SIZE: Vec2 = Vec2::new(10.0, 10.0);
const CONFETTI_MAX_SPEED: f32 = 400.0;

// A component to mark balloon entities.
#[derive(Component)]
struct Balloon;

// A component to manage movement.
#[derive(Component)]
struct Velocity(Vec2);

// A component to mark confetti particle entities.
#[derive(Component)]
struct ConfettiParticle;

// A component to give entities a limited lifespan.
#[derive(Component)]
struct Lifetime(Timer);

// A resource to hold the handle for the balloon texture.
#[derive(Resource)]
struct BalloonTexture(Handle<Image>);

// A resource to manage the balloon spawn timer.
#[derive(Resource)]
struct BalloonSpawnTimer(Timer);

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "Balloons".into(),
                ..default()
            }),
            ..default()
        }))
        .insert_resource(ClearColor(Color::rgb(0.7, 0.8, 0.9)))
        .add_systems(Startup, setup)
        .add_systems(
            Update,
            (
                spawn_balloons,
                apply_velocity,
                handle_balloon_popping,
                apply_gravity_to_confetti,
                cull_despawnable_entities,
            ),
        )
        .run();
}

// System to set up the game on startup.
fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    // Spawn the 2D camera.
    commands.spawn(Camera2dBundle::default());

    // Load the balloon asset.
    let balloon_texture = asset_server.load("balloon.png");
    commands.insert_resource(BalloonTexture(balloon_texture));

    // Initialize the spawn timer.
    commands.insert_resource(BalloonSpawnTimer(Timer::from_seconds(
        BALLOON_SPAWN_TIME,
        TimerMode::Repeating,
    )));
}

// the game window has colorful balloons floating up the screen randomly at different speeds
fn spawn_balloons(
    mut commands: Commands,
    mut timer: ResMut<BalloonSpawnTimer>,
    texture: Res<BalloonTexture>,
    time: Res<Time>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    timer.0.tick(time.delta());
    if timer.0.just_finished() {
        let window = window_query.single();
        let mut rng = thread_rng();

        // Spawn at a random x position at the bottom of the screen.
        let spawn_x = rng.gen_range(-window.width() / 2.0..=window.width() / 2.0);
        let spawn_y = -window.height() / 2.0 - BALLOON_SIZE.y / 2.0;

        // Random upward speed.
        let speed = rng.gen_range(MIN_BALLOON_SPEED..=MAX_BALLOON_SPEED);

        // Random color.
        let color = Color::hsl(rng.gen_range(0.0..=360.0), 0.9, 0.7);

        commands.spawn((
            SpriteBundle {
                texture: texture.0.clone(),
                sprite: Sprite {
                    color,
                    custom_size: Some(BALLOON_SIZE),
                    ..default()
                },
                transform: Transform::from_xyz(spawn_x, spawn_y, 0.0),
                ..default()
            },
            Balloon,
            Velocity(Vec2::new(0.0, speed)),
        ));
    }
}

// System to apply velocity to any entity that has it.
fn apply_velocity(mut query: Query<(&mut Transform, &Velocity)>, time: Res<Time>) {
    for (mut transform, velocity) in &mut query {
        transform.translation += velocity.0.extend(0.0) * time.delta_seconds();
    }
}

// System to handle despawning entities that are off-screen or whose lifetime has expired.
fn cull_despawnable_entities(
    mut commands: Commands,
    mut lifetime_query: Query<(Entity, &mut Lifetime)>,
    balloon_query: Query<(Entity, &Transform), With<Balloon>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    time: Res<Time>,
) {
    // Despawn entities whose lifetime has expired.
    for (entity, mut lifetime) in &mut lifetime_query {
        lifetime.0.tick(time.delta());
        if lifetime.0.finished() {
            commands.entity(entity).despawn();
        }
    }

    // Despawn balloons that have floated off the top of the screen.
    let window = window_query.single();
    let top_boundary = window.height() / 2.0 + BALLOON_SIZE.y / 2.0;
    for (entity, transform) in &balloon_query {
        if transform.translation.y > top_boundary {
            commands.entity(entity).despawn();
        }
    }
}

// when the user clicks on the balloons they pop and confetti comes out
fn handle_balloon_popping(
    mut commands: Commands,
    mouse_button_input: Res<ButtonInput<MouseButton>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    camera_query: Query<(&Camera, &GlobalTransform)>,
    balloon_query: Query<(Entity, &Transform, &Sprite), With<Balloon>>,
) {
    if mouse_button_input.just_pressed(MouseButton::Left) {
        let window = window_query.single();
        let (camera, camera_transform) = camera_query.single();

        if let Some(cursor_pos) = window.cursor_position() {
            if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {
                for (entity, transform, sprite) in &balloon_query {
                    let balloon_pos = transform.translation.truncate();
                    let balloon_size = sprite.custom_size.unwrap_or(BALLOON_SIZE);

                    // AABB collision check.
                    if world_pos.x >= balloon_pos.x - balloon_size.x / 2.0
                        && world_pos.x <= balloon_pos.x + balloon_size.x / 2.0
                        && world_pos.y >= balloon_pos.y - balloon_size.y / 2.0
                        && world_pos.y <= balloon_pos.y + balloon_size.y / 2.0
                    {
                        // Pop the balloon.
                        commands.entity(entity).despawn();

                        // Spawn confetti.
                        let mut rng = thread_rng();
                        for _ in 0..CONFETTI_COUNT {
                            let angle = rng.gen_range(0.0..std::f32::consts::TAU);
                            let speed = rng.gen_range(0.0..=CONFETTI_MAX_SPEED);
                            let velocity = Vec2::new(angle.cos(), angle.sin()) * speed;
                            let color = Color::hsl(rng.gen_range(0.0..=360.0), 0.9, 0.7);

                            commands.spawn((
                                SpriteBundle {
                                    sprite: Sprite {
                                        color,
                                        custom_size: Some(CONFETTI_SIZE),
                                        ..default()
                                    },
                                    transform: Transform::from_translation(balloon_pos.extend(1.0)),
                                    ..default()
                                },
                                ConfettiParticle,
                                Velocity(velocity),
                                Lifetime(Timer::from_seconds(CONFETTI_LIFETIME, TimerMode::Once)),
                            ));
                        }

                        // Only pop one balloon per click.
                        break;
                    }
                }
            }
        }
    }
}

// System to apply gravity to confetti particles.
fn apply_gravity_to_confetti(
    mut query: Query<&mut Velocity, With<ConfettiParticle>>,
    time: Res<Time>,
) {
    for mut velocity in &mut query {
        velocity.0.y -= CONFETTI_GRAVITY * time.delta_seconds();
    }
}